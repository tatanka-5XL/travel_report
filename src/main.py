#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Filename: main.py
Description: Parses waypoints in travel report json input and calculates segments/times and perdiems. Using json file data from /input folder, generated by input.py module

Author: Tatanka5XL
Created: 2025-12-23
Last Modified: 2026-01-10
Version: 0.5
License: Proprietary
"""


from datetime import datetime, timedelta
import json
import os
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment
from openpyxl.worksheet.pagebreak import Break


# =========================
# Helpers
# =========================

def to_isodate(year_str: str, mmdd: str) -> datetime:
    """year + MMDD -> datetime date at 00:00"""
    return datetime.strptime(f"{year_str}{mmdd}", "%Y%m%d")

def to_isodatetime(year_str: str, mmdd: str, hhmm: str) -> datetime:
    """year + MMDD + HHMM -> datetime"""
    return datetime.strptime(f"{year_str}{mmdd}{hhmm}", "%Y%m%d%H%M")

def to_stringday(date_dt: datetime) -> str:
    return date_dt.strftime("%d/%m")

def diff_in_hours(iso_start: datetime, iso_end: datetime) -> float:
    delta = iso_end - iso_start
    return delta.total_seconds() / 3600

def cz_band(hours: float):
    if hours < 5:
        return None
    if hours < 12:
        return "5_to_12"
    if hours < 18:
        return "12_to_18"
    return "over_18"

def foreign_band(hours: float):
    if hours < 1:
        return None
    if hours < 12:
        return "1_to_12"
    if hours < 18:
        return "12_to_18"
    return "over_18"

def apply_meal_reduction(base_amount: float, pct_per_meal: float, meals: int) -> float:
    factor = 1.0 - (meals * (pct_per_meal / 100.0))
    if factor < 0:
        factor = 0.0
    return base_amount * factor

def build_trip_from_waypoints(json_data: dict) -> list[dict]:
    """
    Build trip overview (per day, per country hours + meals) from waypoints,
    with special midnight rules:

    - First trip day: starts at first waypoint time.
    - Middle days: start at 00:00 in first waypoint's country.
    - Last trip day: ends at last waypoint time.
    - Middle days: end at 24:00 in last waypoint's country.
    """
    year = str(json_data["year"])
    waypoints = json_data.get("waypoints", {})

    # sort day keys (MMDD) within same year
    day_keys = sorted(waypoints.keys(), key=lambda x: int(x))
    if not day_keys:
        return []

    first_day_key = day_keys[0]
    last_day_key = day_keys[-1]

    trip_days: list[dict] = []

    for mmdd in day_keys:
        wps = waypoints.get(mmdd) or []
        if not wps:
            continue

        day_date = to_isodate(year, mmdd)           # 00:00
        day_start = day_date
        day_end = day_date + timedelta(days=1)      # next day 00:00
        day_str = to_stringday(day_date)

        # aggregate per country
        agg: dict[str, dict] = {}  # country -> {"country":..., "time_hours":..., "meals":...}

        # meals: sum per country from waypoint entries
        for wp in wps:
            c = (wp.get("country") or "").strip().upper()
            m = int(wp.get("meals", 0) or 0)
            if not c:
                continue
            agg.setdefault(c, {"country": c, "time_hours": 0.0, "meals": 0})
            agg[c]["meals"] += m

        # parse waypoint datetimes for this day
        def wp_dt(wp):
            return to_isodatetime(year, mmdd, str(wp["time"]))

        # ---- Start-of-day segment rule ----
        first_wp = wps[0]
        first_country = (first_wp.get("country") or "").strip().upper()
        first_time = wp_dt(first_wp)

        if mmdd != first_day_key:
            # Middle (or last) day: add time from 00:00 to first waypoint in first waypoint country
            if first_country and first_time > day_start:
                hours = diff_in_hours(day_start, first_time)
                agg.setdefault(first_country, {"country": first_country, "time_hours": 0.0, "meals": 0})
                agg[first_country]["time_hours"] += hours
        # First day: do NOT add 00:00→first waypoint

        # ---- Between-waypoints segments ----
        for i in range(len(wps) - 1):
            cur = wps[i]
            nxt = wps[i + 1]

            cur_country = (cur.get("country") or "").strip().upper()
            if not cur_country:
                continue

            cur_dt = wp_dt(cur)
            nxt_dt = wp_dt(nxt)

            # If the list crosses midnight inside same MMDD (rare), treat next as next day
            if nxt_dt < cur_dt:
                nxt_dt = nxt_dt + timedelta(days=1)

            # Clamp to this day's window just in case
            seg_start = max(cur_dt, day_start)
            seg_end = min(nxt_dt, day_end)

            if seg_end > seg_start:
                hours = diff_in_hours(seg_start, seg_end)
                agg.setdefault(cur_country, {"country": cur_country, "time_hours": 0.0, "meals": 0})
                agg[cur_country]["time_hours"] += hours

        # ---- End-of-day segment rule ----
        last_wp = wps[-1]
        last_country = (last_wp.get("country") or "").strip().upper()
        last_time = wp_dt(last_wp)

        if mmdd != last_day_key:
            # Middle (or first) day: extend from last waypoint to 24:00 in last waypoint country
            if last_country and day_end > last_time:
                hours = diff_in_hours(last_time, day_end)
                agg.setdefault(last_country, {"country": last_country, "time_hours": 0.0, "meals": 0})
                agg[last_country]["time_hours"] += hours
        # Last day: do NOT add last waypoint → midnight

        day_obj = {"date": day_str, "segments": list(agg.values())}
        trip_days.append(day_obj)

    return trip_days


# =========================
# Ask for input file + load JSON
# =========================

default_file = "trep.json"
filename = input(f"Input JSON filename [{default_file}]: ").strip() or default_file

input_path = os.path.join("..", "input", filename)
if not os.path.isfile(input_path):
    raise FileNotFoundError(f"Input file not found: {input_path}")

with open(input_path, "r", encoding="utf-8") as f:
    json_file_data = json.load(f)

year = str(json_file_data["year"])


# =========================
# Build day overview (trip) from WAYPOINTS
# =========================

trip = build_trip_from_waypoints(json_file_data)


# =========================
# Load settings
# =========================

settings_path = os.path.join("..", "config", "settings.json")
if not os.path.isfile(settings_path):
    raise FileNotFoundError(f"Settings file not found: {settings_path}")

with open(settings_path, "r", encoding="utf-8") as f:
    settings = json.load(f)

cz_rates = settings["cz"]["per_diems_czk"]
cz_meal_reduce = settings["cz"]["lowering_percents_per_meal"]

foreign_rates_raw = settings["foreign"]["per_diems"]
foreign_percents = settings["foreign"]["per_diems_percents"]
foreign_meal_reduce = settings["foreign"]["lowering_percents_per_meal"]
pocket_percent = float(settings["foreign"].get("pocket_money_percent", 40))

# Build mapping: "PL" -> {"rate": 50, "currency": "EUR"} from keys like "PL_eur"
foreign_rates = {}
for k, v in foreign_rates_raw.items():
    country, cur = k.split("_", 1)
    foreign_rates[country] = {"rate": float(v), "currency": cur.upper()}

# Exchange rates STRICTLY from input JSON (CNB trip start day)
rates_czk = {}
for c in json_file_data["bank_rates"]["currencies"]:
    code = (c["code"] or "").upper().strip()
    rates_czk[code] = float(c["exchange_rate"])

if "CZK" not in rates_czk:
    raise KeyError(
        "bank_rates.currencies must include CZK with exchange_rate = 1")


# =========================
# Calculate per diems per day
# =========================

for day in trip:
    day["per_diem"] = []
    comments = []

    # ---------- CZ ----------
    cz_seg = next((s for s in day["segments"] if s["country"] == "CZ"), None)
    cz_hours = float(cz_seg.get("time_hours", 0) or 0) if cz_seg else 0.0
    cz_meals = int(cz_seg.get("meals", 0) or 0) if cz_seg else 0

    cz_key = cz_band(cz_hours)
    if cz_key is None:
        day["per_diem"].append({
            "country": "CZ",
            "currency": "CZK",
            "band": "under_5",
            "base": 0,
            "meals": cz_meals,
            "reduction_percent_per_meal": None,
            "amount": 0
        })
        if cz_seg:
            comments.append(f"CZ: {cz_hours:.2f}h <5h ⇒ 0 CZK.")
    else:
        cz_base = float(cz_rates[cz_key])
        cz_pct = float(cz_meal_reduce[cz_key])
        cz_final = apply_meal_reduction(cz_base, cz_pct, cz_meals)
        cz_lowered = cz_base - cz_final

        day["per_diem"].append({
            "country": "CZ",
            "currency": "CZK",
            "band": cz_key,
            "base": cz_base,
            "meals": cz_meals,
            "reduction_percent_per_meal": cz_pct,
            "amount": round(cz_final, 2)
        })
        comments.append(
            f"CZ: {cz_hours:.2f}h ⇒ base {cz_base:.2f} CZK ({cz_key}); "
            f"meals {cz_meals} lowered {cz_lowered:.2f} ⇒ paid {cz_final:.2f} CZK."
        )

    # ---------- FOREIGN ----------
    foreign_segs = [s for s in day["segments"] if s["country"] != "CZ"]
    if not foreign_segs:
        day["comment"] = " | ".join(comments)
        continue

    total_foreign_hours = sum(float(s.get("time_hours", 0) or 0)
                              for s in foreign_segs)
    total_foreign_meals = sum(int(s.get("meals", 0) or 0)
                              for s in foreign_segs)

    # Rule: if CZ >= 5h but foreign < 5h => no foreign per diem
    if cz_hours >= 5 and total_foreign_hours < 5:
        day["per_diem"].append({
            "country": "FOREIGN",
            "currency": None,
            "band": "blocked_cz>=5_foreign<5",
            "base_rate": None,
            "percent": 0,
            "base": 0,
            "foreign_hours_total": round(total_foreign_hours, 2),
            "meals": total_foreign_meals,
            "reduction_percent_per_meal": None,
            "amount": 0,
            "amount_czk": 0,
            "exchange_rate_to_czk": None
        })
        comments.append(
            f"FOREIGN: {total_foreign_hours:.2f}h, but CZ {cz_hours:.2f}h ≥5h and foreign <5h ⇒ 0."
        )
        day["comment"] = " | ".join(comments)
        continue

    # dominant foreign country by time (no FX logic for choosing)
    dominant_seg = max(foreign_segs, key=lambda s: float(
        s.get("time_hours", 0) or 0))
    country = dominant_seg["country"]

    if country not in foreign_rates:
        raise KeyError(
            f"No foreign per diem rate in settings.json for country: {country}")

    band_key = foreign_band(total_foreign_hours)
    cur = foreign_rates[country]["currency"]
    rate = foreign_rates[country]["rate"]

    if band_key is None:
        day["per_diem"].append({
            "country": country,
            "currency": cur,
            "band": "under_1",
            "base_rate": rate,
            "percent": 0,
            "base": 0,
            "foreign_hours_total": round(total_foreign_hours, 2),
            "meals": total_foreign_meals,
            "reduction_percent_per_meal": None,
            "amount": 0,
            "amount_czk": 0,
            "exchange_rate_to_czk": None
        })
        comments.append(
            f"FOREIGN ({country}): {total_foreign_hours:.2f}h <1h ⇒ 0.")
        day["comment"] = " | ".join(comments)
        continue

    percent = float(foreign_percents[band_key])
    foreign_base = rate * (percent / 100.0)

    red_pct = float(foreign_meal_reduce.get(band_key, 0))
    foreign_final = apply_meal_reduction(
        foreign_base, red_pct, total_foreign_meals)
    foreign_lowered = foreign_base - foreign_final

    foreign_amount = round(foreign_final, 2)

    if cur not in rates_czk:
        raise KeyError(
            f"Missing exchange rate for {cur} in input JSON bank_rates.currencies (CNB start-day)."
        )

    foreign_amount_czk = round(foreign_amount * rates_czk[cur], 2)

    day["per_diem"].append({
        "country": country,
        "currency": cur,
        "band": band_key,
        "base_rate": rate,
        "percent": percent,
        "base": round(foreign_base, 2),
        "foreign_hours_total": round(total_foreign_hours, 2),
        "meals": total_foreign_meals,
        "reduction_percent_per_meal": red_pct,
        "amount": foreign_amount,
        "exchange_rate_to_czk": rates_czk[cur],
        "amount_czk": foreign_amount_czk
    })

    comments.append(
        f"FOREIGN ({country}): total {total_foreign_hours:.2f}h ⇒ {band_key} ({percent:.1f}%) "
        f"base {foreign_base:.2f} {cur}; meals {total_foreign_meals} lowered {foreign_lowered:.2f} ⇒ "
        f"paid {foreign_final:.2f} {cur}. "
        f"Converted: {foreign_amount:.2f} {cur} × {rates_czk[cur]:.4f} = {foreign_amount_czk:.2f} CZK."
    )

    day["comment"] = " | ".join(comments)


# =========================
# Pocket money + totals (CZK)
#  - pocket money ONLY from FOREIGN
#  - pocket money is % of FOREIGN per-diem BASES before meal reduction
#  - foreign bases converted to CZK using CNB start-day rates from input JSON
# =========================

foreign_base_total_czk = 0.0
per_diem_paid_total_czk = 0.0

for day in trip:
    # Sum FOREIGN bases before reductions (convert to CZK)
    for p in day.get("per_diem", []):
        cur = p.get("currency")
        if not cur or cur == "CZK":
            continue  # only foreign
        base = float(p.get("base", 0) or 0)
        if cur not in rates_czk:
            raise KeyError(
                f"Missing exchange rate for {cur} in input JSON bank_rates.currencies."
            )
        foreign_base_total_czk += base * rates_czk[cur]

    # Sum actually paid per diems in CZK (CZK + foreign)
    cz_paid = 0.0
    cz_entry = next((p for p in day.get("per_diem", [])
                    if p.get("country") == "CZ"), None)
    if cz_entry:
        cz_paid = float(cz_entry.get("amount", 0) or 0)

    foreign_paid_czk = 0.0
    foreign_entry = next((p for p in day.get("per_diem", []) if p.get(
        "currency") and p.get("currency") != "CZK"), None)
    if foreign_entry:
        foreign_paid_czk = float(foreign_entry.get("amount_czk", 0) or 0)

    per_diem_paid_total_czk += (cz_paid + foreign_paid_czk)

pocket_money_czk = round(foreign_base_total_czk * (pocket_percent / 100.0), 2)

summary = {
    "total_foreign_per_diem_base_czk": round(foreign_base_total_czk, 2),
    "total_per_diem_paid_czk": round(per_diem_paid_total_czk, 2),
    "pocket_money_percent": pocket_percent,
    "total_pocket_money_czk": pocket_money_czk,
    "total_money_czk": round(per_diem_paid_total_czk + pocket_money_czk, 2),
}


# =========================
# Output: days + summary
# =========================

base_name = os.path.splitext(filename)[0]
output_filename = f"{base_name}_seg.json"
output_path = os.path.join("..", "output", output_filename)

output = {
    "days": trip,
    "summary": summary
}

print(json.dumps(output, indent=2, ensure_ascii=False))

with open(output_path, "w", encoding="utf-8") as f:
    json.dump(output, f, indent=2, ensure_ascii=False)

print(f"\nProcessed data saved to {output_path}")


# ===========================
# Excel sheet generating part
# ===========================

MAX_ROWS = 50
MAX_COLS = 6  # A..F

wb = Workbook()
ws = wb.active
ws.title = "Vyúčtování služební cesty"

# --- Print setup (A4 portrait, 1 page) ---
ws.print_area = f"A1:F{MAX_ROWS}"
ws.page_setup.paperSize = ws.PAPERSIZE_A4
ws.page_setup.orientation = ws.ORIENTATION_PORTRAIT
ws.page_setup.fitToWidth = 1
ws.page_setup.fitToHeight = 1
ws.sheet_properties.pageSetUpPr.fitToPage = True

# Margins (inches)
ws.page_margins.left = 0.25
ws.page_margins.right = 0.25
ws.page_margins.top = 0.5
ws.page_margins.bottom = 0.5
ws.page_margins.header = 0.3
ws.page_margins.footer = 0.3

# --- Defaults (font + alignment) applied to A1:F50 only ---
font = Font(name="Helvetica", size=10)
align = Alignment(horizontal="left", vertical="center")

for row in ws.iter_rows(min_row=1, max_row=MAX_ROWS, min_col=1, max_col=MAX_COLS):
    for cell in row:
        cell.font = font
        cell.alignment = align

# Row height
for r in range(1, MAX_ROWS + 1):
    ws.row_dimensions[r].height = 12

# Column widths – fill whole A4 width
ws.column_dimensions["A"].width = 9.5
ws.column_dimensions["B"].width = 37.0
ws.column_dimensions["C"].width = 13.0
ws.column_dimensions["D"].width = 11.0
ws.column_dimensions["E"].width = 11.0
ws.column_dimensions["F"].width = 8.5

# --- Header text ---
bold = Font(name="Helvetica", size=10, bold=True)

ws["A1"] = "Vyúčtování služební cesty"
ws["C1"] = "Profisolv, s.r.o."  
ws["E1"] = "Číslo:"
ws["E2"] = "List:"

ws["A4"] = "Pracovník:"
ws["A5"] = "Účel cesty:"
ws["A6"] = "Prostředek:"
ws["A7"] = "Trasa:"


# Popis trasy
ws["B9"] = "Popis trasy"
ws["B9"].alignment = Alignment(horizontal="center", vertical="center")

headers = ["Bod", "Místo", "Datum", "Čas", "Doba", "Jídla"]
for col_letter, txt in zip("ABCDEF", headers):
    c = ws[f"{col_letter}10"]
    c.value = txt

# Naklady
ws["B30"] = "Náklady"
ws["B30"].alignment = Alignment(horizontal="center", vertical="center")

ws["A31"] = "Stravné"
headers = ["Den", "Popis", "Plné CZ", "Plné za.", "Celk. / den"]
for col_letter, txt in zip("ABDEF", headers):
    c = ws[f"{col_letter}32"]
    c.value = txt
ws["C43"] = "Celkem:"
ws["C44"] = "Kapesne:"
ws["D44"] = "xxxxxxx"
ws["F44"] = "xxxxxxx"


ws["A46"] = "Ubytování"
headers = ["Datum", "Popis", "Doklad č.", "Částka"]
for col_letter, txt in zip("ABEF", headers):
    c = ws[f"{col_letter}47"]
    c.value = txt
ws["E53"] = "Celkem:"

ws["A54"] = "Ostatní"
headers = ["Datum", "Popis", "Doklad č.", "Částka"]
for col_letter, txt in zip("ABEF", headers):
    c = ws[f"{col_letter}55"]
    c.value = txt
ws["E61"] = "Celkem:"

# --- Final counts ---
ws["E63"] = "Záloha:"
ws["A63"] = "Zúčtováno dne:"
ws["A64"] = "Podpis:"
ws["C64"] = "Mezisoučet:"
ws["E64"] = "Náklady:"
ws["E65"] = "K vyplacení:"

# --- Save ---
os.makedirs("../output", exist_ok=True)
out_path = "../output/spam.xlsx"
wb.save(out_path)
print("Excel saved to:", os.path.abspath(out_path))